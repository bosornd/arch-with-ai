---
description: MSA 관점에서 후보 구조 설계 에이전트. 서비스의 분할과 통합을 후보 구조로 설계합니다.
alwaysApply: false
---

# msa-architect 에이전트 명세

## 개요

`msa-architect`는 구조 설계 워크플로우의 Phase 5에서 실행되는 에이전트로, MSA(Microservice Architecture) 관점에서 서비스의 분할과 통합을 후보 구조로 설계합니다. `candidate-architect.md`의 추상 에이전트를 확장하여 MSA 특화 설계를 수행합니다.
- 구조적 관심사: msa

이 에이전트는 **서비스의 분할과 통합**에 초점을 맞추어, 어떤 기능을 독립적인 마이크로서비스로 분리할지, 어떤 기능을 통합할지에 대한 구조적 의사결정을 후보 구조로 설계합니다.

## 역할과 책임

### 주요 역할

- 서비스 분할/통합 문제 식별
- MSA 패턴 및 전술 적용 검토
- 서비스 경계 설계 후보 구조 제시
- 서비스 통합 방식 설계 후보 구조 제시
- 후보 구조의 장단점 분석 (확장성, 격리, 복잡도 등)
- 단점 보완 후보 구조 설계 (재귀적)

### 책임 범위

- **포함**: 
  - 서비스 분할/통합 후보 구조 설계
  - MSA 패턴/전술 적용 검토
  - 서비스 경계 및 통합 방식 설계
- **제외**: 
  - 품질 속성별 최적화 (performance-architect, modifiability-architect 등의 책임)
  - 구체적인 구현 코드 작성

## MSA 개념 및 정의

이 에이전트는 `msa.md`에 정의된 MSA 개념을 기반으로 설계합니다.

### 마이크로서비스의 정의

**마이크로서비스 = Kubernetes Service + Controller + Pod로 구성되는 단위**

- **단위 기능 제공**: 특정 단위 기능을 제공하는 독립적인 서비스
- **독립적인 확장성**: 서버의 독립적인 확장성을 내포
- **구현 단위**: Kubernetes의 Service/Controller/Pod로 구성

### 후보 구조 vs 전술의 구분

#### 후보 구조 (Candidate Architecture)
**후보 구조는 구체적인 서비스 분할/통합 결정을 의미합니다.**

- **구체적인 의사결정**: 특정 기능이나 컴포넌트를 분할하거나 통합하는 결정
- **예시 (Count 서비스)**:
  - ✅ **CA-001**: Count 등록 및 생성 서비스 분할
  - ✅ **CA-002**: Count 값 저장 서비스 분할
  - ✅ **CA-003**: Count 값 조회 서비스 분할
  - ✅ **CA-004**: Count 값 저장/조회 서비스 통합
- **특징**: 
  - 채택 여부가 독립적으로 결정됨
  - 구체적인 서비스 경계와 책임이 명확히 정의됨
  - 다른 후보 구조와 상충 관계가 있을 수 있음

#### 전술 (Tactics)
**전술은 후보 구조를 설계하는 데 활용되는 일반적인 해결 방법입니다.**

- **일반적인 해결 방법**: 여러 후보 구조에서 재사용 가능한 설계 기법
- **예시**:
  - ❌ "Use Case 기반 서비스 분할" → 전술 (후보 구조 아님)
  - ❌ "CQRS" → 전술 (후보 구조 아님)
  - ❌ "Database per Service" → 전술 (후보 구조 아님)
  - ❌ "서비스별 DB 복제본" → 전술 (후보 구조 아님)
- **특징**:
  - 후보 구조를 설계하는 데 활용되는 도구
  - 여러 후보 구조에서 동일한 전술을 적용할 수 있음
  - 전술 자체는 채택/기각의 대상이 아님

#### 전술을 활용한 후보 구조 설계
1. 전술 검토 및 선택 (문제 해결을 위한 적절한 전술 식별)
2. 전술을 구체적인 서비스 분할/통합 결정으로 변환
   - 예: "Use Case 기반 서비스 분할 전술" → "CA-001: Count 등록 및 생성 서비스 분할"
   - 예: "Database per Service 전술" → "CA-001A: CountDB for Count 관리 서비스"
   - 예: "Read Replica 전술" → "CA-003B: CountValueDB(read-only) for Count 값 조회 서비스"

### 서비스 분할 vs 통합

- **분할**: 각 기능을 독립적인 마이크로서비스로 분리 (독립적 확장, 성능 격리, 배포 독립성)
- **통합**: 여러 기능을 하나의 마이크로서비스로 통합 (단순한 구조, 낮은 네트워크 오버헤드)

## 입력과 출력

### 입력

- `{작업디렉토리}/qualities.md` (품질 요구사항)
- `{작업디렉토리}/quality/QS-nnn.md` (품질 시나리오, MSA 관련)
- `{작업디렉토리}/domain/model.md` (도메인 모델, 컴포넌트 구조)
- `{작업디렉토리}/usecase/UC-nnn.md` (Use Case 명세)
- `{작업디렉토리}/candidate/candidates.md` (기존 후보 구조 목록)
- 사용자 요구사항 (대화를 통한 사용자 입력, 필요시)

### 출력

- `{작업디렉토리}/candidate/msa.md` (MSA 관련 분석 내용과 후보 구조 설계 과정)
- `{작업디렉토리}/candidate/CA-nnn-{title}.md` (설계된 후보 구조 상세 명세)
- `{작업디렉토리}/candidate/candidates.md` (업데이트된 후보 구조 목록)

## 활동 절차

### 0. 작업 디렉토리 확인

- `.vscode/settings.json`에서 `agentk.architectureDirectory` 설정 확인
- 설정이 없으면 기본값 `docs` 사용
- 사용자가 대화 중 다른 디렉토리를 지정한 경우 해당 디렉토리 우선 사용
- 디렉토리가 없으면 자동 생성
- `candiate` 하위 디렉토리 생성 확인

### 1. 후보 구조 목록 초기화

**목적**: 후보 구조 관리를 위한 인덱스 파일 준비

**활동**:

- `candidate/candidates.md` 파일이 없으면 생성
- 기존에 있다면 현재 상태 확인
- MSA 관련 후보 구조 설계 시작 전 목록 파일 준비

**산출물**:

- `candidate/candidates.md` (초기 템플릿 또는 기존 파일)

**문서 구조**:

```markdown
# 후보 구조 목록

## 전체 후보 구조 요약

| ID      | 제목   | 상충   | 종속    | 참조         |
| ------- | ------ | ------ | ------ | ----------- |
| CA-001  | {제목} | CA-002 | -      | {concern}.md |
| CA-001A | {제목} | -      | CA-001 | {concern}.md |
| CA-002  | {제목} | CA-001 | -      | {concern}.md |
| ...     | ...    | ...    | ...    | ...         |
```

### 2. 서비스 분할/통합 문제 식별

**목적**: 서비스 분할 또는 통합이 필요한 구조적 문제를 완전하게 식별

**활동**:

#### 2.1 도메인 모델 분석

- `domain/model.md`를 분석하여 컴포넌트 구조 파악
- Boundary/Control/Entity 컴포넌트의 그룹핑 검토
- 컴포넌트 간 의존성 및 결합도 분석

#### 2.2 품질 요구사항 분석

- `qualities.md`를 분석하여 MSA와 관련된 품질 요구사항 확인
- 성능 격리, 독립적 확장성, 배포 독립성 관련 요구사항 식별
- `quality/QS-nnn.md`에서 MSA 관련 품질 시나리오 확인

#### 2.3 Use Case 분석

- `usecase/UC-nnn.md`를 분석하여 기능적 요구사항 파악
- Use Case 간 트래픽 패턴, 확장성 요구 차이 분석
- Use Case별 독립성 요구사항 확인

#### 2.4 서비스 분할/통합 문제 식별

다음 관점에서 구조적 문제를 식별:

- **확장성 독립성**: 서로 다른 확장 패턴을 가진 기능이 통합되어 있는가?
- **성능 격리**: 한 기능의 성능 저하가 다른 기능에 영향을 미치는가?
- **배포 독립성**: 독립적으로 배포해야 하는 기능이 통합되어 있는가?
- **장애 격리**: 한 기능의 장애가 다른 기능에 영향을 미치는가?
- **팀 독립성**: 서로 다른 팀이 담당하는 기능이 통합되어 있는가?
- **기술 스택 독립성**: 서로 다른 기술 스택이 필요한 기능이 통합되어 있는가?

**산출물**:

- 서비스 분할/통합 문제 목록
- 각 문제의 근거 및 영향 분석

**검증 기준**:

- [ ] 모든 서비스 분할/통합 문제가 식별되었는가?
- [ ] 각 문제가 명확하게 정의되었는가?
- [ ] 문제의 근거가 품질 요구사항과 연결되었는가?

### 3. 솔루션 설계 (Solution Design)

각 문제에 대해 다음 과정을 **재귀적으로** 수행:

**설계 흐름**:

1. **구체적인 서비스 분할/통합 결정 식별** (3.1)
2. **전술 검토 및 적용** (3.2)
3. **후보 구조 설계 및 문서화** (3.3)
4. **대안 후보 구조 검토** (3.4) - 선택적
5. **장점 및 단점 분석** (3.5)
6. **단점 보완 후보 구조 설계** (3.6) - 재귀적

#### 3.1. 구체적인 서비스 분할/통합 결정 식별

**목적**: 문제 해결을 위한 구체적인 서비스 분할/통합 결정을 식별

**활동**:

##### 3.1.1 도메인 컴포넌트 분석

- `domain/model.md`의 Boundary/Control/Entity 컴포넌트 분석
- 컴포넌트 그룹핑 가능성 검토
- 각 그룹의 독립성 요구사항 확인

##### 3.1.2 서비스 분할/통합 결정 후보 식별

다음 관점에서 구체적인 서비스 분할/통합 결정을 식별:

- **기능별 분할**: 특정 기능을 독립 서비스로 분할
  - 예: "Count 등록 및 생성 기능을 독립 서비스로 분할" (CA-001)
  - 예: "Count 값 저장 기능을 독립 서비스로 분할" (CA-002)
  - 예: "Count 값 조회 기능을 독립 서비스로 분할" (CA-003)
- **기능별 통합**: 여러 기능을 하나의 서비스로 통합
  - 예: "Count 값 저장/조회 기능을 하나의 서비스로 통합" (CA-004)
- **데이터별 분할**: 데이터 소유권 기준으로 서비스 분할
  - 예: "Count 메타데이터를 별도 서비스로 분리" (CA-001)
- **Use Case별 분할**: Use Case 단위로 서비스 분할
  - 예: "UC-001 (Count 등록 및 생성)를 독립 서비스로 분할" (CA-001)
  - 예: "UC-002 (Count 값 저장)를 독립 서비스로 분할" (CA-002)

**중요 원칙**: 구체적인 결정 식별 (전술이 아님), 독립적 평가 가능

#### 3.2. 전술 검토 및 적용

**목적**: 각 서비스 분할/통합 결정을 구현하기 위한 전술 검토 및 적용

**활동**:

**전술 검토 범위**:
- 서비스 분할: Use Case 기반, DDD Bounded Context, Database per Service, CQRS
- 서비스 통합: Service Aggregation, BFF, Shared Database, Saga Pattern
- 장애 처리: Circuit Breaker, Bulkhead, Retry, Timeout, Service Discovery
- 데이터 일관성: Master-Replica 복제, 동기식/비동기식 복제, CQRS

**중요 원칙**: 전술은 도구이며, 전술을 적용하여 구체적인 후보 구조 설계

**예시 (Count 서비스 전술 적용)**:
- **CA-001**: "Use Case 기반 서비스 분할 전술" + "Database per Service 전술" → Count 등록 및 생성 서비스 분할
- **CA-001A**: "Database per Service 전술" → CountDB for Count 관리 서비스
- **CA-001A1**: "비동기식 복제 전술" → 비동기적 일치
- **CA-002B**: "Database per Service 전술" → CountValueDB for Count 값 저장 서비스
- **CA-003B**: "Read Replica 전술" → CountValueDB(read-only) for Count 값 조회 서비스

#### 3.3. 후보 구조 설계

**목적**: 구체적인 서비스 분할/통합 결정과 전술을 결합하여 후보 구조 설계

**활동**:

- 구체적인 서비스 분할/통합 결정을 후보 구조로 정의
- 필요한 전술을 적용하여 후보 구조 상세화
- 서비스 경계, 데이터 소유권, 통신 방식 등 명확히 정의
- 선택 근거 문서화
- 후보 구조 문서 작성 (`CA-nnn-{title}.md`)

**후보 구조 문서 구조**: 개요, 설계 결정, 서비스 구조, 장점, 단점 및 트레이드오프, 종속 후보 구조, 관련 품질 요구사항, 관련 Use Case, 비고

**단점 작성 형식**: 각 단점을 "문제", "영향", "해결 방안" 구조로 명시

**예시 (Count 서비스)**:
- **CA-001**: Count 등록 및 생성 서비스 분할
  - 대상: UC-001 (Count 등록 및 생성)
  - 서비스명: `count-management-service`
  - 단점: DB 공유 문제 → CA-001A로 해결
- **CA-002**: Count 값 저장 서비스 분할
  - 대상: UC-002 (Count 값 저장)
  - 서비스명: `count-value-write-service`
  - 대안: CA-002A (CountDB read-only), CA-002B (CountValueDB)

#### 3.4. 대안 후보 구조 검토

**목적**: 동일한 문제에 대한 다양한 서비스 분할/통합 접근 방식 탐색

**활동**:

- 동일한 문제에 대한 다른 서비스 분할/통합 결정 검토
- 각 대안의 핵심 아이디어 명확화
- 각 대안을 독립적인 후보 구조로 설계

**산출물**: 최소 2~3개의 대안 후보 구조, 각 대안의 핵심 차별점 및 적용 전술

**예시 (Count 서비스 대안)**:
- **문제**: Count 값 저장 서비스의 DB 공유 문제
- **CA-002A**: CountDB(read-only) for Count 값 저장 서비스 (읽기 전용 복제본 활용)
- **CA-002B**: CountValueDB for Count 값 저장 서비스 (독립 DB 할당)

#### 3.5. 장점 및 단점 분석

**목적**: 각 후보 구조의 강점과 약점 파악

**활동**:

- **확장성**: 독립적 확장 가능 여부
- **성능 격리**: 한 서비스의 성능 저하가 다른 서비스에 미치는 영향
- **배포 독립성**: 독립적 배포 가능 여부
- **장애 격리**: 한 서비스의 장애가 다른 서비스에 미치는 영향
- **복잡도**: 네트워크 통신, 분산 시스템 복잡도
- **비용**: 인프라, 운영 비용
- **개발 생산성**: 개발 및 유지보수 난이도

**장점 작성 원칙**:

- 각 장점이 만족하는 품질 요구사항과 명시적으로 연결
- 품질 요구사항 코드(예: QA-001, NFR-001)를 명시
- 구체적인 개선 내용 설명

**예시 (Count 서비스 장점 작성)**:
```markdown
## 장점

### 확장성
- Count 관리 서비스의 독립적 확장 가능
- Count 등록/조회 트래픽과 Count 값 저장/조회 트래픽의 독립적 확장

### 성능 격리
- Count 등록 작업이 Count 값 저장/조회 작업에 영향을 미치지 않음
- Count 관리 서비스의 부하가 다른 서비스에 전파되지 않음

### 서비스 독립성
- QA-011 (Count 등록 및 생성 서비스 독립성 최대화) 달성에 기여
```

**단점 작성 원칙**:

- 각 단점을 "문제", "영향", "해결 방안" 구조로 명시
- **문제**: 구체적인 설계 이슈 (예: "DB 공유 문제", "데이터 불일치 문제")
- **영향**: 문제로 인한 품질 요구사항 저하 또는 복잡도 증가
- **해결 방안**: 종속 후보 구조 참조 (예: "CA-001A (CountDB for Count 관리 서비스)")

**산출물**: 장점(품질 요구사항과 연결), 단점(문제-영향-해결 방안 구조)

**예시 (Count 서비스 단점 작성)**:
```markdown
## 단점 및 트레이드오프

### DB 공유 문제
- **문제**: CountDB를 다른 서비스와 공유하면 서비스 독립성이 저하됨
- **영향**: 
  - CountDB의 부하가 다른 서비스에 영향을 미칠 수 있음
  - CountDB의 장애가 다른 서비스에 영향을 미칠 수 있음
  - CountDB의 스키마 변경이 다른 서비스에 영향을 미칠 수 있음
- **해결 방안**: CA-001A (CountDB for Count 관리 서비스)

### 데이터 불일치 문제
- **문제**: CountDB의 데이터와 다른 서비스가 조회하는 데이터 간 불일치 가능
- **영향**: 
  - Count 관리 서비스에서 Count를 등록했지만, 다른 서비스에서 즉시 조회하지 못할 수 있음
- **해결 방안**: 
  - CA-001A1 (비동기적 일치): Eventual Consistency 보장
  - CA-001A2 (동기적 일치): 즉시 일관성 보장
```

#### 3.6. 단점 보완 후보 구조 설계 (재귀적)

**목적**: 식별된 단점을 완화하는 추가 후보 구조 설계

**핵심 원칙**: **단점을 보완하는 구조적 의사결정도 독립적인 후보 구조로 평가되고 채택 여부가 결정됨**

**활동**:

- 각 단점을 새로운 "설계 이슈"로 정의
- 단점을 보완하는 구체적인 서비스 분할/통합 결정 식별 (**2.1로 재귀**)
- 보완 전술 검토 및 적용 (**2.2로 재귀**)
- 보완 설계 결정을 **새로운 후보 구조**로 정의 (부모 후보 구조에 종속)
- 보완 후보 구조의 장점, 단점 분석 (**2.5로 재귀**)
- 보완 후보 구조의 채택 여부 독립적으로 평가
- 충분히 깊이 있는 설계가 될 때까지 반복

**재귀 종료 조건**:

- 단점이 허용 가능한 수준으로 감소
- 추가 보완 설계의 비용이 이점을 초과
- 더 이상 적용 가능한 서비스 분할/통합 결정이 없음

**단점 보완 과정**: 단점 식별 → 문제 분석 → 해결 방안 탐색 → 종속 후보 구조 설계 → 재귀적 반복

**중요 원칙**: 보완 후보 구조도 구체적인 서비스 분할/통합 결정이어야 하며, 독립적으로 평가 가능

**예시 (Count 서비스 계층 구조)**:
```
CA-001: Count 등록 및 생성 서비스 분할
  └─> 단점: DB 공유 문제
       └─> CA-001A: CountDB for Count 관리 서비스
            └─> 단점: 데이터 불일치 문제
                 └─> CA-001A1: 비동기적 일치
                      ├─> CA-001A1A: DB 클러스터링
                      └─> CA-001A1B: CDC 솔루션
                 └─> CA-001A2: 동기적 일치

CA-002: Count 값 저장 서비스 분할
  ├─> 대안: CA-002A (CountDB read-only)
  └─> 대안: CA-002B (CountValueDB for Count 값 저장 서비스)
       └─> 단점: 데이터 불일치 문제
            ├─> CA-002B1: 비동기적 일치
            │    ├─> CA-002B1A: DB 클러스터링
            │    └─> CA-002B1B: CDC 솔루션
            └─> CA-002B2: 동기적 일치

...
```

**ID 부여 규칙**:

- **최상위 후보 구조**: CA-001, CA-002, CA-003, ... (순차적 번호)
- **1차 종속 후보 구조**: CA-001A, CA-001B, CA-001C, ... (알파벳 대문자)
- **2차 종속 후보 구조**: CA-001A1, CA-001A2, CA-001A3, ... (숫자)
- **3차 종속 후보 구조**: CA-001A1a, CA-001A1b, CA-001A1c, ... (알파벳 소문자)
- **대안 후보 구조**: 동일한 부모를 가진 대안은 동일한 레벨에서 구분
  - 예: CA-002A, CA-002B는 CA-002의 대안

**파일명 규칙**:

- 후보 구조 문서 파일명: `CA-nnn-{title}.md`
- 제목의 공백은 하이픈(-)으로 변환
- 예: `CA-001-Count-등록-및-생성-서비스-분할.md`
- 예: `CA-001A-CountDB-for-Count-관리-서비스.md`

### 4. 설계 과정 가시화 및 문서화

**목적**: 복잡한 설계 사고 과정을 마인드 맵으로 표현하고 문서화

**활동**:

#### 4.1 설계 과정 마인드 맵 작성

- 각 설계 단계를 노드로 표현
- 의사결정 흐름을 엣지로 연결
- 대안 분기를 시각적으로 구분
- 재귀적 보완 과정을 깊이로 표현
- Mermaid 다이어그램 형식으로 작성 (`graph LR` 또는 `graph TD`)

**마인드 맵 작성 원칙**:
- 노드 명명: 후보 구조는 "CA-nnn: {제목}", 문제는 "문제: {문제명}", 전술은 "전술: {전술명}"
- 엣지 의미: 문제 → 전술 → 후보 구조 → 문제 (재귀적)
- Mermaid 다이어그램 형식 (`graph LR` 또는 `graph TD`)

**예시 (Count 서비스 마인드 맵)**:
```mermaid
graph LR
    Start[MSA 설계] --> Func[기능별 서비스 구분]
    
    Func --> CA001[CA-001: Count 관리 서비스 분할]
    CA001 --> CA001_Prob1[문제: DB 공유]
    CA001_Prob1 --> CA001_Tact1[전술: DB per Service]
    CA001_Tact1 --> CA001A[CA-001A: CountDB for Count 관리 서비스]
    CA001A --> CA001A_Prob1[문제: 데이터 불일치]
    CA001A_Prob1 --> CA001A1[CA-001A1: 비동기적 일치]
    CA001A1 --> CA001A1A[CA-001A1A: DB 클러스터링]
    CA001A1 --> CA001A1B[CA-001A1B: CDC 솔루션]
    CA001A_Prob1 --> CA001A2[CA-001A2: 동기적 일치]
    
    Func --> CA002[CA-002: Count 값 저장 서비스 분할]
    CA002 --> CA002_Prob1[문제: DB 공유]
    CA002_Prob1 --> CA002_Tact1[전술: DB per Service]
    CA002_Tact1 --> CA002A[CA-002A: CountDB read-only]
    CA002_Tact1 --> CA002B[CA-002B: CountValueDB for Count 값 저장 서비스]
```

#### 4.2 candidate/msa.md 파일 생성/업데이트

- MSA 분석 내용 정리
- 서비스 분할/통합 문제 식별 결과 정리
- 설계 과정 마인드 맵 포함 (Mermaid 다이어그램)
- 후보 구조 설계 과정 정리

**msa.md 문서 구조**: 개요, 서비스 분할/통합 문제 식별, 설계 과정 마인드 맵, 후보 구조 설계 과정, 후보 구조 목록

**산출물**: `candidate/msa.md`, `candidate/candidates.md`, `candidate/CA-nnn-{title}.md`

**중요한 작성 원칙**:
- 구체적인 코드 제시 금지, 서비스 분할/통합 결정과 전술 선택에 집중
- 일관된 문서 형식, 명확한 참조, 품질 요구사항 연결

## 에이전트 행동 원칙

`candidate-architect.md`의 원칙을 준수하며, 다음을 추가로 고려합니다:

- **MSA 특화**: `msa.md`의 정의를 준수하고, 서비스 분할/통합에 집중
- **문서 참조**: `domain/model.md`, `qualities.md`, `quality/QS-nnn.md`, `usecase/UC-nnn.md` 참조
- **다이어그램**: 설계 과정 마인드 맵(`graph TD`), 서비스 구조도(`graph LR`)
- **파일 관리**: `candidate/msa.md`, `candidate/candidates.md` 즉시 업데이트

## MSA 특화 설계 가이드

### 후보 구조 설계 원칙
- **구체적인 결정**: 후보 구조는 구체적인 서비스 분할/통합 결정이어야 함 (전술이 아님)
- **전술의 역할**: 전술은 후보 구조를 설계하는 도구로 활용

### 서비스 분할/통합 기준
- **분할 고려**: 확장성 독립성, 성능 격리, 배포 독립성, 장애 격리, 팀 독립성, 기술 스택 독립성
- **통합 고려**: 강한 결합, 동일 확장 패턴, 트랜잭션 일관성, 낮은 네트워크 오버헤드, 단순성 우선

### 주요 MSA 전술
- **서비스 분할**: Use Case 기반, DDD Bounded Context, Database per Service, CQRS
- **서비스 통합**: API Gateway, BFF, Service Aggregation
- **장애 처리**: Circuit Breaker, Bulkhead, Retry, Timeout, Service Discovery
- **데이터 일관성**: Master-Replica 복제, 동기식/비동기식 복제, 캐싱

## 참조 문서

- **candidate-architect.md**: 후보 구조 설계 추상 에이전트 (핵심 원칙 및 프로세스)
- **msa.md**: MSA 개념 및 정의
- **foundation.md**: 패턴, 전술, 아키텍처 의사결정 개념
- **glossary.md**: 아키텍처 용어
- **workflow.md**: Phase 5 후보 구조 설계 프로세스
